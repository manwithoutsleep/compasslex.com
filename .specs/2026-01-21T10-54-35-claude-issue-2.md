# Implementation Plan: Migrate to Next.js with Tailwind, hosted on Vercel

**GitHub Issue:** #2
**Created:** 2026-01-21T10:54:35
**Updated:** 2026-01-21T11:10:00
**Status:** Ready for Approval (Windows/PowerShell Environment Confirmed)

---

## Overview

### Summary

Migrate the CompassLex.com website from Angular 20 with NgRx state management to Next.js 15 with Tailwind CSS, deploying on Vercel. This migration modernizes the platform while maintaining exact functionality and appearance for end users.

**Development Environment**: Windows 11 using PowerShell. All shell commands in this specification use PowerShell syntax.

**Repository Structure**: This migration uses a separate repository approach. The new Next.js application is being built in the `compasslex-nextjs` repository (already created and initialized), while the existing Angular application in the `compasslex.com` repository serves as a read-only reference. Both repositories are located adjacent to each other locally for easy cross-reference during implementation.

### Goals and Success Criteria

1. **Functional Parity**: All features work identically to current Angular implementation
2. **Visual Parity**: UI/UX matches pixel-perfect to current design
3. **Data Continuity**: Continue reading from `counselor.json` and `newsletter.json`
4. **Code Quality**: Pass all quality checks (TypeScript, ESLint, Prettier, tests)
5. **Platform Modernization**: Deploy successfully on Vercel with modern Next.js architecture
6. **Test Coverage**: Comprehensive test coverage for all features
7. **SOLID Compliance**: Code adheres to SOLID principles and clean code practices

### Scope and Complexity

**Complexity: HIGH**

This is a complete platform migration involving:

- 11 counselor profiles with detailed information
- 24 newsletters with PDF downloads
- 9 route pages (home, meet-us, counselor detail, our-services, faq, getting-started, resources, contact-us, newsletters)
- Complex state management (NgRx → modern Next.js patterns)
- Google Maps integration
- Responsive design
- Asset migration (images, PDFs, videos)

**Note:** The contact-us page will be included but will not have a functional contact form (not currently in Angular app). This may be added as a future enhancement.

**Estimated Implementation Time:** This is a multi-week project requiring careful attention to detail.

---

## Technical Approach

### Architectural Decisions and Rationale

#### 1. **Next.js App Router (not Pages Router)**

- **Decision**: Use Next.js 15 App Router with React Server Components
- **Rationale**:
    - Modern standard for Next.js applications
    - Better performance with Server Components
    - Simplified data fetching patterns
    - Built-in streaming and suspense support
- **SOLID Alignment**: Single Responsibility - Server Components handle data, Client Components handle interactivity

#### 2. **State Management Strategy**

- **Decision**: Replace NgRx with React Server Components + Context API for client state
- **Rationale**:
    - Current NgRx implementation is over-engineered for static JSON data
    - Server Components eliminate need for complex state management
    - Context API sufficient for minimal client state (e.g., mobile menu)
- **SOLID Alignment**:
    - **Interface Segregation**: Small, focused contexts instead of monolithic store
    - **Dependency Inversion**: Components depend on context interfaces, not implementations

#### 3. **Data Layer Architecture**

- **Decision**: Server-side JSON file reading with TypeScript type safety
- **Rationale**:
    - No runtime HTTP requests needed - data baked into server responses
    - Prepares for future database migration (abstraction layer)
    - Type-safe data access
- **SOLID Alignment**:
    - **Open/Closed**: Data service abstraction allows future DB migration without changing components
    - **Dependency Inversion**: Components depend on data service interface, not file I/O

#### 4. **Component Architecture**

- **Decision**: Colocated Server + Client Components with clear separation
- **Rationale**:
    - Server Components for static content and data fetching
    - Client Components only where needed (maps, mobile menu)
    - Smaller bundle sizes, better performance
- **SOLID Alignment**:
    - **Single Responsibility**: Each component has one clear purpose
    - **Liskov Substitution**: Components use standard React interfaces

#### 5. **Styling Strategy**

- **Decision**: Tailwind CSS with component-specific classes
- **Rationale**:
    - Modern utility-first approach
    - Smaller CSS bundles (no unused styles)
    - Easier to maintain than SCSS variables
    - Match existing color scheme through Tailwind config
- **SOLID Alignment**: Separation of concerns - styling through utilities vs embedded styles

#### 6. **Testing Strategy**

- **Decision**: Vitest + React Testing Library + Playwright
- **Rationale**:
    - Vitest: Fast, modern, Vite-based (aligns with Next.js)
    - RTL: Component testing focused on user behavior
    - Playwright: E2E testing for critical user flows
- **SOLID Alignment**: Tests verify contracts (interfaces), not implementations

### Design Patterns

1. **Repository Pattern**: Data access layer abstraction

    ```typescript
    interface CounselorRepository {
        getAllCounselors(): Promise<Counselor[]>;
        getCounselorByName(firstname: string): Promise<Counselor | null>;
    }
    ```

2. **Factory Pattern**: Component builders for consistent UI elements (cards, buttons)

3. **Composition Pattern**: Small, focused components composed into pages

### Integration Points

- **Google Maps**: Migrate from `@angular/google-maps` to `@googlemaps/js-api-loader` with React wrapper
- **PDF Serving**: Static file serving from `public/` directory
- **Environment Variables**: `.env.local` for Google Maps API key

### Potential Risks and Mitigation

| Risk                            | Likelihood | Impact | Mitigation Strategy                                          |
| ------------------------------- | ---------- | ------ | ------------------------------------------------------------ |
| Visual differences from Angular | Medium     | High   | Pixel-perfect comparison screenshots, manual review          |
| Google Maps integration issues  | Medium     | Medium | Test early, use proven React wrapper library                 |
| SEO regression                  | Low        | High   | Leverage Next.js SSR, verify meta tags, test with Lighthouse |
| Missing functionality           | Medium     | High   | Comprehensive test coverage, user acceptance testing         |
| Performance degradation         | Low        | Medium | Monitor Core Web Vitals, optimize images                     |
| Data structure changes breaking | Low        | High   | Maintain exact JSON schema, add validation tests             |

### SOLID Principles Application

#### Single Responsibility Principle (SRP)

- Each component does ONE thing: display counselor card, render navigation, display information
- Data services only handle data access, not business logic
- Utility functions are pure and focused

#### Open/Closed Principle (OCP)

- Data repository abstraction allows switching JSON → DB without changing components
- Component composition allows extending UI without modifying existing components
- Tailwind utilities allow styling changes without touching component code

#### Liskov Substitution Principle (LSP)

- All React components follow standard React.FC interface
- Server and Client components substitutable where appropriate

#### Interface Segregation Principle (ISP)

- Small, focused TypeScript interfaces (Counselor, Newsletter)
- Context APIs provide only needed state, not everything
- Component props are minimal and specific

#### Dependency Inversion Principle (DIP)

- Components depend on data service interfaces, not file reading implementation
- High-level page components don't depend on low-level utility details
- Testing uses mock implementations of interfaces

---

## Implementation Steps

### Phase 0: Setup and Planning

#### Repository Structure

**Development Environment**: Windows 11 with PowerShell

**Separate Repository Approach**: This migration uses two separate Git repositories:

```
C:/src/gihub/mws/
├── compasslex.com/                  ← Angular repo (READ-ONLY reference)
│   ├── src/
│   ├── package.json
│   └── ...
└── compasslex-nextjs/               ← Next.js repo (ACTIVE working directory)
    ├── app/
    ├── components/
    ├── package.json
    └── ...
```

**Working Directory**: Claude Code operates from the **compasslex-nextjs** directory
**Reference Repo**: Angular code is referenced via `../compasslex.com/` when needed

**Command Shell**: All commands in this spec use PowerShell syntax (Windows 11)

**Benefits**:

- Clean separation of old and new codebases
- Standard Next.js structure at repository root
- Vercel deploys from repo root (no subdirectory configuration)
- Clean Git history for new application
- Easy rollback: point domain back to Angular if needed
- Archive Angular repo after successful migration

---

#### Step 0.1: Create Feature Branch

**Status**: ✅ COMPLETED (Repo already initialized)

The `compasslex-nextjs` repository has been created using Vercel's Next.js Boilerplate and is cloned locally adjacent to the Angular reference repository.

```bash
# In compasslex-nextjs directory
git checkout -b issue-2
```

**Rationale**: Isolate migration work from main branch in the new Next.js repository
**SOLID**: N/A (infrastructure)

---

#### Step 0.2: Initialize Next.js Project Structure

**Status**: ✅ COMPLETED (Already done via Vercel Boilerplate)

The Next.js 15 project has been initialized with:

- ✅ TypeScript
- ✅ ESLint
- ✅ Tailwind CSS
- ✅ App Router
- ✅ Standard Next.js directory structure

**Verification**:

```bash
# Verify the setup works
npm run build
npm run lint
```

**Expected Structure**:

```
compasslex-nextjs/
├── app/
│   ├── layout.tsx
│   └── page.tsx
├── public/
├── package.json
├── next.config.js
├── tailwind.config.ts
└── tsconfig.json
```

**Rationale**: Vercel's Next.js Boilerplate provides production-ready configuration
**SOLID**: Framework provides SRP through clear directory structure

---

#### Step 0.3: Set Up Development Environment

**Actions**:

1. **Install Additional Dependencies**:

    ```bash
    npm install @googlemaps/js-api-loader
    npm install -D vitest @testing-library/react @testing-library/jest-dom jsdom
    npm install -D prettier prettier-plugin-tailwindcss
    npm install -D @playwright/test
    ```

2. **Configure Environment Variables**:
    - Create `.env.example`:
        ```
        NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=your-google-maps-api-key-here
        ```
    - Create `.env.local` (git-ignored):
        ```
        NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=actual-key-from-angular-repo
        ```

3. **Reference to Angular Repo**:
    - Google Maps API key can be found in `../compasslex.com/.env` or `../compasslex.com/src/environments/environment.ts`

**Verification**:

```bash
tsc --noEmit
npx prettier --check "**/*.{ts,tsx,json,md}"
npm run build
npm run dev  # Should start on http://localhost:3000
```

**Rationale**: Establish tooling and environment before code migration
**SOLID**: N/A (infrastructure)

---

### Working Across Repositories

**During Implementation**, Claude Code will:

1. **Read from Angular repo** (reference only):

    ```powershell
    # Examples:
    Read file: ../compasslex.com/src/app/models/counselor.ts
    Read file: ../compasslex.com/src/assets/data/counselor.json
    Read file: ../compasslex.com/src/sass/_variables.scss
    ```

2. **Write to Next.js repo** (all new code):

    ```powershell
    # Examples:
    Write file: types/models.ts
    Write file: services/data-repository.ts
    Write file: app/meet-us/page.tsx
    ```

3. **Copy assets between repos** (if needed):

    ```powershell
    # Copy data files
    Copy-Item -Path "../compasslex.com/src/assets/data/*" -Destination "public/data/"

    # Copy static assets recursively
    Copy-Item -Path "../compasslex.com/src/assets/*" -Destination "public/assets/" -Recurse
    ```

**Important**: All Git commands and npm commands work the same in PowerShell. Git commits happen in the **compasslex-nextjs** repository only.

---

### Phase 1: Core Infrastructure (TDD Foundation)

#### Step 1.1: Define TypeScript Interfaces (TDD Red Phase)

**Test First** - Create `__tests__/types/models.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import type { Counselor, Newsletter, CounselorData, NewsletterData } from '@/types/models';

describe('Type Definitions', () => {
    it('should accept valid Counselor object', () => {
        const counselor: Counselor = {
            appointmentlink: 'https://example.com',
            credentials: ['MA'],
            directoryid: '123',
            email: 'test@test.com',
            firstname: 'John',
            insurance: ['Aetna'],
            lastname: 'Doe',
            longdescription: '<p>Description</p>',
            memberships: ['ACA'],
            phone: '555-1234',
            practitionerid: '1',
            shortdescription: 'Short desc',
            titles: ['MA'],
            id: '1',
        };
        expect(counselor).toBeDefined();
    });

    // Similar tests for Newsletter, CounselorData, NewsletterData
});
```

**Implementation** - Create `types/models.ts`:

```typescript
export interface Counselor {
    appointmentlink: string;
    credentials: string[];
    directoryid: string;
    email: string;
    firstname: string;
    insurance: string[];
    lastname: string;
    longdescription: string;
    memberships: string[];
    phone: string;
    practitionerid: string;
    shortdescription: string;
    titles: string[];
    id: string;
}

export interface Newsletter {
    description: string | null;
    id: string;
    quarter: string;
    title: string;
    year: string;
}

export interface CounselorData {
    counselorList: Counselor[];
}

export interface NewsletterData {
    newsletterList: Newsletter[];
}
```

**Verification**:

```bash
tsc --noEmit
npx vitest run __tests__/types/models.test.ts
```

**Rationale**: Type safety prevents runtime errors, matches existing JSON schema exactly
**SOLID**:

- **ISP**: Separate interfaces for each concern
- **SRP**: Each interface defines one entity

---

#### Step 1.2: Create Data Repository Layer (TDD)

**Test First** - Create `__tests__/services/data-repository.test.ts`:

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { CounselorRepository, NewsletterRepository } from '@/services/data-repository';

describe('CounselorRepository', () => {
    let repo: CounselorRepository;

    beforeEach(() => {
        repo = new CounselorRepository();
    });

    it('should load all counselors from JSON', async () => {
        const counselors = await repo.getAllCounselors();
        expect(counselors).toBeInstanceOf(Array);
        expect(counselors.length).toBeGreaterThan(0);
    });

    it('should find counselor by firstname', async () => {
        const counselor = await repo.getCounselorByName('Joanna');
        expect(counselor).toBeDefined();
        expect(counselor?.firstname).toBe('Joanna');
    });

    it('should return null for non-existent counselor', async () => {
        const counselor = await repo.getCounselorByName('NonExistent');
        expect(counselor).toBeNull();
    });
});

describe('NewsletterRepository', () => {
    // Similar tests for newsletter repository
});
```

**Implementation** - Create `services/data-repository.ts`:

```typescript
import { readFile } from 'fs/promises';
import { join } from 'path';
import type { Counselor, Newsletter, CounselorData, NewsletterData } from '@/types/models';

export interface ICounselorRepository {
    getAllCounselors(): Promise<Counselor[]>;
    getCounselorByName(firstname: string): Promise<Counselor | null>;
}

export interface INewsletterRepository {
    getAllNewsletters(): Promise<Newsletter[]>;
    getNewsletterById(id: string): Promise<Newsletter | null>;
}

export class CounselorRepository implements ICounselorRepository {
    private dataPath = join(process.cwd(), 'public', 'data', 'counselor.json');

    async getAllCounselors(): Promise<Counselor[]> {
        const raw = await readFile(this.dataPath, 'utf-8');
        const data: CounselorData = JSON.parse(raw);
        return data.counselorList;
    }

    async getCounselorByName(firstname: string): Promise<Counselor | null> {
        const counselors = await this.getAllCounselors();
        return counselors.find((c) => c.firstname === firstname) || null;
    }
}

export class NewsletterRepository implements INewsletterRepository {
    private dataPath = join(process.cwd(), 'public', 'data', 'newsletter.json');

    async getAllNewsletters(): Promise<Newsletter[]> {
        const raw = await readFile(this.dataPath, 'utf-8');
        const data: NewsletterData = JSON.parse(raw);
        return data.newsletterList;
    }

    async getNewsletterById(id: string): Promise<Newsletter | null> {
        const newsletters = await this.getAllNewsletters();
        return newsletters.find((n) => n.id === id) || null;
    }
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix services/data-repository.ts __tests__/services/data-repository.test.ts
npx prettier --write services/data-repository.ts __tests__/services/data-repository.test.ts
npx vitest run __tests__/services/data-repository.test.ts
```

**Rationale**: Repository pattern abstracts data access, preparing for future DB migration
**SOLID**:

- **DIP**: Components depend on ICounselorRepository interface, not implementation
- **OCP**: Can add database implementation without changing interface
- **SRP**: Repository only handles data access, not business logic

---

#### Step 1.3: Copy Data Files and Assets from Angular Repo

**Actions** (from compasslex-nextjs working directory):

1. **Create directory structure**:

    ```powershell
    New-Item -Path "public/data" -ItemType Directory -Force
    New-Item -Path "public/assets" -ItemType Directory -Force
    ```

2. **Copy data files from Angular repo**:

    ```powershell
    Copy-Item -Path "../compasslex.com/src/assets/data/counselor.json" -Destination "public/data/"
    Copy-Item -Path "../compasslex.com/src/assets/data/newsletter.json" -Destination "public/data/"
    ```

3. **Copy all static assets from Angular repo**:

    ```powershell
    Copy-Item -Path "../compasslex.com/src/assets/newsletters" -Destination "public/assets/" -Recurse
    Copy-Item -Path "../compasslex.com/src/assets/pdf" -Destination "public/assets/" -Recurse
    Copy-Item -Path "../compasslex.com/src/assets/site-images" -Destination "public/assets/" -Recurse
    Copy-Item -Path "../compasslex.com/src/assets/slider-images" -Destination "public/assets/" -Recurse
    Copy-Item -Path "../compasslex.com/src/assets/icons" -Destination "public/assets/" -Recurse
    Copy-Item -Path "../compasslex.com/src/assets/videos" -Destination "public/assets/" -Recurse
    ```

4. **Copy favicon if needed**:
    ```powershell
    Copy-Item -Path "../compasslex.com/src/favicon.ico" -Destination "public/"
    ```

**Verification**:

```powershell
Get-ChildItem public/data          # Should show counselor.json and newsletter.json
Get-ChildItem public/assets        # Should show newsletters/, pdf/, site-images/, etc.
npx vitest run __tests__/services/data-repository.test.ts  # Should pass
```

**Rationale**: Next.js serves `public/` directory statically; copy once from Angular repo
**SOLID**: N/A (infrastructure)

**Note**: These are one-time copies. Any future updates to counselor/newsletter data should be made in the Next.js repo's `public/data/` directory.

---

### Phase 2: Tailwind Configuration and Design System

#### Step 2.1: Configure Tailwind Theme (TDD)

**Test First** - Create `__tests__/styles/tailwind-config.test.ts`:

```typescript
import { describe, it, expect } from 'vitest';
import resolveConfig from 'tailwindcss/resolveConfig';
import tailwindConfig from '@/tailwind.config';

describe('Tailwind Configuration', () => {
    const config = resolveConfig(tailwindConfig);

    it('should include custom color palette', () => {
        expect(config.theme.colors).toHaveProperty('deep-sapphire');
        expect(config.theme.colors).toHaveProperty('warm-sand');
        expect(config.theme.colors).toHaveProperty('raspberry-smoothie');
    });

    it('should set correct max width', () => {
        expect(config.theme.maxWidth).toHaveProperty('site', '1440px');
    });
});
```

**Implementation** - Update `tailwind.config.ts`:

```typescript
import type { Config } from 'tailwindcss';

const config: Config = {
    content: [
        './pages/**/*.{js,ts,jsx,tsx,mdx}',
        './components/**/*.{js,ts,jsx,tsx,mdx}',
        './app/**/*.{js,ts,jsx,tsx,mdx}',
    ],
    theme: {
        extend: {
            colors: {
                // New site colors
                'polar-mist': '#ddeff7',
                'bengal-blue': '#b1cfdd',
                'raspberry-smoothie': '#c6a3b3',
                'north-pole-blue': '#709eb4',
                'ultra-pure-white': '#f8f9f3',
                // Old site colors (primary palette)
                'deep-sapphire': '#191248',
                'warm-sand': '#f2c58a',
                'peach-puff': '#fbe3c9',
                'pure-white': '#ffffff',
                'royal-indigo': '#43208a',
            },
            maxWidth: {
                site: '1440px',
            },
            minWidth: {
                site: '320px',
            },
            fontFamily: {
                sans: ['Roboto', 'sans-serif'],
            },
        },
    },
    plugins: [],
};

export default config;
```

**Verification**:

```bash
tsc --noEmit
npx vitest run __tests__/styles/tailwind-config.test.ts
npm run build
```

**Rationale**: Match existing color scheme, prepare for consistent styling
**SOLID**: **SRP** - Configuration centralized in one file

---

#### Step 2.2: Create Reusable UI Components (TDD)

**Test First** - Create `__tests__/components/ui/card.test.tsx`:

```typescript
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import { Card, CardTitle, CardBody } from '@/components/ui/card'

describe('Card Component', () => {
  it('should render card with title and body', () => {
    render(
      <Card>
        <CardTitle>Test Title</CardTitle>
        <CardBody>Test Body</CardBody>
      </Card>
    )

    expect(screen.getByText('Test Title')).toBeInTheDocument()
    expect(screen.getByText('Test Body')).toBeInTheDocument()
  })

  it('should apply correct styling classes', () => {
    const { container } = render(<Card><CardBody>Content</CardBody></Card>)
    const card = container.firstChild
    expect(card).toHaveClass('border-3', 'border-deep-sapphire', 'rounded')
  })
})
```

**Implementation** - Create `components/ui/card.tsx`:

```typescript
import type { ReactNode } from 'react'

interface CardProps {
  children: ReactNode
  className?: string
}

export function Card({ children, className = '' }: CardProps) {
  return (
    <div className={`border-3 border-deep-sapphire rounded shadow-md m-1 ${className}`}>
      {children}
    </div>
  )
}

export function CardTitle({ children, className = '' }: CardProps) {
  return (
    <div className={`bg-deep-sapphire text-polar-mist text-lg font-medium py-2 px-5 flex items-center justify-center ${className}`}>
      {children}
    </div>
  )
}

export function CardBody({ children, className = '' }: CardProps) {
  return (
    <div className={`p-2.5 ${className}`}>
      {children}
    </div>
  )
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix components/ui/card.tsx __tests__/components/ui/card.test.tsx
npx prettier --write components/ui/card.tsx __tests__/components/ui/card.test.tsx
npx vitest run __tests__/components/ui/card.test.tsx
```

**Rationale**: Reusable card component matches Angular `.ui-card` styling
**SOLID**:

- **SRP**: Card only renders styled container
- **OCP**: Can extend with variants without modifying base
- **ISP**: Minimal props interface

**Similar TDD Process for**:

- `components/ui/button.tsx`
- `components/ui/heading.tsx`

---

### Phase 3: Page Routing and Layouts

#### Step 3.1: Create Root Layout (TDD)

**Test First** - Create `__tests__/app/layout.test.tsx`:

```typescript
import { describe, it, expect } from 'vitest'
import { render } from '@testing-library/react'
import RootLayout from '@/app/layout'

describe('RootLayout', () => {
  it('should render children with Roboto font', () => {
    const { container } = render(
      <RootLayout>
        <div>Test Content</div>
      </RootLayout>
    )

    const html = container.querySelector('html')
    expect(html).toHaveClass('font-sans')
  })

  it('should include metadata', () => {
    // Test metadata exports
    expect(RootLayout).toBeDefined()
  })
})
```

**Implementation** - Create `app/layout.tsx`:

```typescript
import type { Metadata } from 'next'
import { Roboto } from 'next/font/google'
import './globals.css'
import Navigation from '@/components/navigation'

const roboto = Roboto({
  weight: ['400', '700'],
  subsets: ['latin'],
  display: 'swap',
})

export const metadata: Metadata = {
  title: 'Compass Christian Counseling - Lexington, KY',
  description: 'Professional Christian counseling services in Lexington, Kentucky',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en" className={roboto.className}>
      <body className="bg-pure-white min-h-screen">
        <Navigation />
        <main className="max-w-site mx-auto px-4">
          {children}
        </main>
      </body>
    </html>
  )
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix app/layout.tsx __tests__/app/layout.test.tsx
npx prettier --write app/layout.tsx __tests__/app/layout.test.tsx
npx vitest run __tests__/app/layout.test.tsx
npm run dev # Manual check
```

**Rationale**: Root layout provides consistent structure across all pages
**SOLID**: **SRP** - Layout only handles structure, not content

---

#### Step 3.2: Implement Navigation Component (TDD)

**Test First** - Create `__tests__/components/navigation.test.tsx`:

```typescript
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Navigation from '@/components/navigation'

describe('Navigation', () => {
  it('should render all navigation links', () => {
    render(<Navigation />)

    expect(screen.getByText('Home')).toBeInTheDocument()
    expect(screen.getByText('Meet Us')).toBeInTheDocument()
    expect(screen.getByText('Our Services')).toBeInTheDocument()
    expect(screen.getByText('FAQ')).toBeInTheDocument()
    expect(screen.getByText('Getting Started')).toBeInTheDocument()
    expect(screen.getByText('Resources')).toBeInTheDocument()
    expect(screen.getByText('Contact Us')).toBeInTheDocument()
    expect(screen.getByText('Newsletters')).toBeInTheDocument()
  })

  it('should have correct href attributes', () => {
    render(<Navigation />)

    const homeLink = screen.getByText('Home').closest('a')
    expect(homeLink).toHaveAttribute('href', '/')
  })
})
```

**Implementation** - Create `components/navigation.tsx`:

```typescript
'use client'

import Link from 'next/link'
import { usePathname } from 'next/navigation'
import { useState } from 'react'

const NAV_LINKS = [
  { href: '/', label: 'Home' },
  { href: '/meet-us', label: 'Meet Us' },
  { href: '/our-services', label: 'Our Services' },
  { href: '/faq', label: 'FAQ' },
  { href: '/getting-started', label: 'Getting Started' },
  { href: '/resources', label: 'Resources' },
  { href: '/contact-us', label: 'Contact Us' },
  { href: '/newsletters', label: 'Newsletters' },
] as const

export default function Navigation() {
  const pathname = usePathname()
  const [mobileMenuOpen, setMobileMenuOpen] = useState(false)

  return (
    <nav className="bg-deep-sapphire text-polar-mist">
      <div className="max-w-site mx-auto px-4">
        {/* Desktop Navigation */}
        <div className="hidden md:flex space-x-8 py-4">
          {NAV_LINKS.map(link => (
            <Link
              key={link.href}
              href={link.href}
              className={`hover:text-warm-sand transition-colors ${
                pathname === link.href ? 'font-bold text-warm-sand' : ''
              }`}
            >
              {link.label}
            </Link>
          ))}
        </div>

        {/* Mobile Navigation - TODO: Implement hamburger menu */}
        <div className="md:hidden py-4">
          <button onClick={() => setMobileMenuOpen(!mobileMenuOpen)}>
            Menu
          </button>
          {mobileMenuOpen && (
            <div className="flex flex-col space-y-2 mt-4">
              {NAV_LINKS.map(link => (
                <Link key={link.href} href={link.href}>
                  {link.label}
                </Link>
              ))}
            </div>
          )}
        </div>
      </div>
    </nav>
  )
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix components/navigation.tsx __tests__/components/navigation.test.tsx
npx prettier --write components/navigation.tsx __tests__/components/navigation.test.tsx
npx vitest run __tests__/components/navigation.test.tsx
npm run dev # Manual check navigation
```

**Rationale**: Central navigation matches Angular routing structure
**SOLID**:

- **SRP**: Navigation only handles links and menu state
- **OCP**: Can add new links without modifying component logic

---

### Phase 4: Page Implementations (TDD for Each)

#### Step 4.1: Home Page

**Test First** - `__tests__/app/page.test.tsx`:

```typescript
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import Home from '@/app/page'

describe('Home Page', () => {
  it('should render welcome heading', () => {
    render(<Home />)
    expect(screen.getByRole('heading', { level: 1 })).toBeInTheDocument()
  })

  it('should display introductory content', () => {
    render(<Home />)
    expect(screen.getByText(/Compass Christian Counseling/i)).toBeInTheDocument()
  })
})
```

**Implementation** - `app/page.tsx`:

```typescript
export default function Home() {
  return (
    <div className="py-8">
      <h1 className="text-4xl font-bold text-deep-sapphire mb-6">
        Welcome to Compass Christian Counseling
      </h1>
      {/* Content matching current home page */}
    </div>
  )
}
```

**Verification Process After Implementation**:

```bash
tsc --noEmit
npx eslint --fix app/page.tsx __tests__/app/page.test.tsx
npx prettier --write app/page.tsx __tests__/app/page.test.tsx
npx vitest run __tests__/app/page.test.tsx
```

---

#### Step 4.2: Meet Us Page (Counselor Listing)

**Test First** - `__tests__/app/meet-us/page.test.tsx`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import MeetUsPage from '@/app/meet-us/page';

// Mock repository
vi.mock('@/services/data-repository', () => ({
    CounselorRepository: vi.fn().mockImplementation(() => ({
        getAllCounselors: vi.fn().mockResolvedValue([
            {
                firstname: 'Joanna',
                lastname: 'Tidei',
                shortdescription: 'Test description',
                titles: ['M.A., LPCA'],
                email: 'joanna@compasslex.com',
                // ... other required fields
            },
        ]),
    })),
}));

describe('Meet Us Page', () => {
    it('should display all counselors', async () => {
        render(await MeetUsPage());

        expect(screen.getByText('Joanna Tidei')).toBeInTheDocument();
        expect(screen.getByText(/Test description/)).toBeInTheDocument();
    });
});
```

**Implementation** - `app/meet-us/page.tsx`:

```typescript
import { CounselorRepository } from '@/services/data-repository'
import CounselorCard from '@/components/counselor-card'

export default async function MeetUsPage() {
  const repo = new CounselorRepository()
  const counselors = await repo.getAllCounselors()

  return (
    <div className="py-8">
      <h1 className="text-3xl font-bold text-deep-sapphire mb-6">Meet Our Counselors</h1>
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        {counselors.map(counselor => (
          <CounselorCard key={counselor.id} counselor={counselor} />
        ))}
      </div>
    </div>
  )
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix app/meet-us/page.tsx __tests__/app/meet-us/page.test.tsx
npx prettier --write app/meet-us/page.tsx __tests__/app/meet-us/page.test.tsx
npx vitest run __tests__/app/meet-us/page.test.tsx
```

---

#### Step 4.3: Counselor Detail Page (Dynamic Route)

**Test First** - `__tests__/app/meet-us/[firstname]/page.test.tsx`:

```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen } from '@testing-library/react';
import CounselorDetailPage from '@/app/meet-us/[firstname]/page';

// Mock repository
vi.mock('@/services/data-repository', () => ({
    CounselorRepository: vi.fn().mockImplementation(() => ({
        getCounselorByName: vi.fn().mockResolvedValue({
            firstname: 'Joanna',
            lastname: 'Tidei',
            longdescription: '<p>Full bio here</p>',
            credentials: ['M.A.', 'LPCA'],
            // ... other fields
        }),
    })),
}));

describe('Counselor Detail Page', () => {
    it('should display counselor full bio', async () => {
        const params = { firstname: 'Joanna' };
        render(await CounselorDetailPage({ params }));

        expect(screen.getByText('Joanna Tidei')).toBeInTheDocument();
        expect(screen.getByText(/Full bio here/)).toBeInTheDocument();
    });

    it('should display credentials list', async () => {
        const params = { firstname: 'Joanna' };
        render(await CounselorDetailPage({ params }));

        expect(screen.getByText(/M.A./)).toBeInTheDocument();
        expect(screen.getByText(/LPCA/)).toBeInTheDocument();
    });
});
```

**Implementation** - `app/meet-us/[firstname]/page.tsx`:

```typescript
import { notFound } from 'next/navigation'
import { CounselorRepository } from '@/services/data-repository'

export async function generateStaticParams() {
  const repo = new CounselorRepository()
  const counselors = await repo.getAllCounselors()

  return counselors.map(counselor => ({
    firstname: counselor.firstname,
  }))
}

export default async function CounselorDetailPage({
  params,
}: {
  params: { firstname: string }
}) {
  const repo = new CounselorRepository()
  const counselor = await repo.getCounselorByName(params.firstname)

  if (!counselor) {
    notFound()
  }

  return (
    <div className="py-8 max-w-4xl mx-auto">
      <h1 className="text-3xl font-bold text-deep-sapphire mb-2">
        {counselor.firstname} {counselor.lastname}
      </h1>
      <p className="text-lg text-raspberry-smoothie mb-6">
        {counselor.titles.join(', ')}
      </p>

      <div dangerouslySetInnerHTML={{ __html: counselor.longdescription }} />

      {/* Credentials, Insurance, Memberships sections */}
    </div>
  )
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix app/meet-us/[firstname]/page.tsx __tests__/app/meet-us/[firstname]/page.test.tsx
npx prettier --write app/meet-us/[firstname]/page.tsx __tests__/app/meet-us/[firstname]/page.test.tsx
npx vitest run __tests__/app/meet-us/[firstname]/page.test.tsx
npm run build # Verify static generation
```

**Rationale**: Dynamic routes with static generation for optimal performance
**SOLID**:

- **SRP**: Page only handles rendering, repo handles data
- **DIP**: Page depends on ICounselorRepository interface

---

#### Step 4.4: Newsletters Page

**Similar TDD approach**:

1. Write tests for newsletter listing
2. Implement `app/newsletters/page.tsx`
3. Create newsletter card component
4. Verify with tests and manual check

---

**Note:** The existing Angular application has a contact-us route, but no functional contact form currently exists. The Next.js migration will maintain the contact-us page as an informational page but will not add a contact form at this time. This may be added as a future enhancement.

---

#### Steps 4.5-4.9: Remaining Pages

Implement using same TDD approach:

- `app/our-services/page.tsx`
- `app/faq/page.tsx`
- `app/getting-started/page.tsx`
- `app/resources/page.tsx`
- `app/contact-us/page.tsx` (informational page with contact info, no form)

Each follows pattern:

1. Write test
2. Implement page
3. Verify (tsc, eslint, prettier, vitest)
4. Manual visual check

---

### Phase 5: Google Maps Integration

#### Step 5.1: Create Maps Component (TDD)

**Test First** - `__tests__/components/google-map.test.tsx`:

```typescript
import { describe, it, expect, vi } from 'vitest'
import { render, screen, waitFor } from '@testing-library/react'
import GoogleMap from '@/components/google-map'

// Mock Google Maps loader
vi.mock('@googlemaps/js-api-loader', () => ({
  Loader: vi.fn().mockImplementation(() => ({
    load: vi.fn().mockResolvedValue({
      maps: {
        Map: vi.fn(),
        Marker: vi.fn(),
      }
    })
  }))
}))

describe('GoogleMap Component', () => {
  it('should render map container', () => {
    render(<GoogleMap />)
    expect(screen.getByTestId('google-map')).toBeInTheDocument()
  })

  it('should initialize map on mount', async () => {
    render(<GoogleMap />)
    await waitFor(() => {
      // Verify map initialization
    })
  })
})
```

**Implementation** - `components/google-map.tsx`:

```typescript
'use client'

import { useEffect, useRef } from 'react'
import { Loader } from '@googlemaps/js-api-loader'

interface GoogleMapProps {
  center?: { lat: number; lng: number }
  zoom?: number
}

export default function GoogleMap({
  center = { lat: 38.0406, lng: -84.5037 }, // Lexington, KY
  zoom = 12
}: GoogleMapProps) {
  const mapRef = useRef<HTMLDivElement>(null)

  useEffect(() => {
    const loader = new Loader({
      apiKey: process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY || '',
      version: 'weekly',
    })

    loader.load().then(() => {
      if (mapRef.current) {
        const map = new google.maps.Map(mapRef.current, {
          center,
          zoom,
        })

        new google.maps.Marker({
          position: center,
          map,
          title: 'Compass Christian Counseling',
        })
      }
    })
  }, [center, zoom])

  return (
    <div
      ref={mapRef}
      data-testid="google-map"
      className="w-full h-96 rounded shadow-md"
    />
  )
}
```

**Verification**:

```bash
tsc --noEmit
npx eslint --fix components/google-map.tsx __tests__/components/google-map.test.tsx
npx prettier --write components/google-map.tsx __tests__/components/google-map.test.tsx
npx vitest run __tests__/components/google-map.test.tsx
npm run dev # Manual map display check
```

**Rationale**: Client component for interactive map integration
**SOLID**: **SRP** - Component only handles map rendering

---

### Phase 6: Testing and Quality Assurance

#### Step 6.1: Component Testing Suite

**Actions**:

1. Ensure all components have unit tests
2. Aim for >80% code coverage on components
3. Test user interactions (clicks, form submissions)

**Verification**:

```bash
npx vitest run --coverage
```

**Coverage Goals**:

- Components: >80%
- Services/Repositories: >90%
- Pages: >70%

---

#### Step 6.2: Integration Testing

**Create** - `__tests__/integration/navigation-flow.test.tsx`:

```typescript
import { describe, it, expect } from 'vitest';
import { render, screen } from '@testing-library/react';
import { userEvent } from '@testing-library/user-event';

describe('Navigation Flow', () => {
    it('should navigate from home to meet-us to counselor detail', async () => {
        const user = userEvent.setup();

        // Test navigation flow
        // Verify data loading
        // Verify page transitions
    });
});
```

---

#### Step 6.3: E2E Testing with Playwright

**Create** - `e2e/homepage.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';

test('homepage displays correctly', async ({ page }) => {
    await page.goto('http://localhost:3000');

    await expect(page.getByRole('heading', { level: 1 })).toBeVisible();
    await expect(page.getByRole('navigation')).toBeVisible();
});

test('can navigate to counselor detail page', async ({ page }) => {
    await page.goto('http://localhost:3000/meet-us');

    await page.getByText('Joanna Tidei').click();
    await expect(page).toHaveURL(/\/meet-us\/Joanna/);
    await expect(page.getByText(/Life is often full of difficulty/)).toBeVisible();
});
```

**Run E2E Tests**:

```bash
npx playwright test
npx playwright test --ui # For debugging
```

---

#### Step 6.4: Visual Regression Testing

**Process**:

1. Take screenshots of current Angular app
2. Take screenshots of Next.js app
3. Compare pixel-by-pixel using Playwright

**Create** - `e2e/visual-regression.spec.ts`:

```typescript
import { test, expect } from '@playwright/test';

test('homepage visual regression', async ({ page }) => {
    await page.goto('http://localhost:3000');
    await expect(page).toHaveScreenshot('homepage.png');
});

test('meet-us page visual regression', async ({ page }) => {
    await page.goto('http://localhost:3000/meet-us');
    await expect(page).toHaveScreenshot('meet-us.png');
});
```

**Verification**:

```bash
npx playwright test --update-snapshots # First run
npx playwright test # Subsequent runs
```

---

### Phase 7: Deployment Preparation

#### Step 7.1: Environment Configuration

**Create** - `.env.example`:

```
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=your-api-key-here
```

**Create** - `.env.local` (not committed):

```
NEXT_PUBLIC_GOOGLE_MAPS_API_KEY=actual-key
```

**Verification**:

```bash
npm run build
npm run start
# Test production build locally
```

---

#### Step 7.2: Vercel Configuration

**Create** - `vercel.json`:

```json
{
    "framework": "nextjs",
    "buildCommand": "npm run build",
    "devCommand": "npm run dev",
    "installCommand": "npm install",
    "env": {
        "NEXT_PUBLIC_GOOGLE_MAPS_API_KEY": "@google-maps-api-key"
    }
}
```

**Setup Vercel**:

1. Connect GitHub repository
2. Configure environment variables in Vercel dashboard
3. Set up automatic deployments on push to main

---

#### Step 7.3: Performance Optimization

**Actions**:

1. Optimize images using Next.js `<Image>` component
2. Enable static generation for all pages
3. Minimize JavaScript bundle size

**Create** - `next.config.js`:

```javascript
/** @type {import('next').NextConfig} */
const nextConfig = {
    images: {
        formats: ['image/avif', 'image/webp'],
    },
    experimental: {
        optimizePackageImports: ['@googlemaps/js-api-loader'],
    },
};

module.exports = nextConfig;
```

**Verification**:

```bash
npm run build
npx @next/bundle-analyzer
```

**Performance Targets**:

- Lighthouse Score: >90
- First Contentful Paint: <1.5s
- Time to Interactive: <3s
- Cumulative Layout Shift: <0.1

---

#### Step 7.4: SEO Optimization

**Ensure each page has**:

- Proper `<title>` and `<meta description>`
- OpenGraph tags for social sharing
- Structured data for counselors

**Example** - `app/meet-us/[firstname]/page.tsx`:

```typescript
export async function generateMetadata({ params }: { params: { firstname: string } }) {
    const repo = new CounselorRepository();
    const counselor = await repo.getCounselorByName(params.firstname);

    if (!counselor) return {};

    return {
        title: `${counselor.firstname} ${counselor.lastname} - Compass Christian Counseling`,
        description: counselor.shortdescription,
        openGraph: {
            title: `${counselor.firstname} ${counselor.lastname}`,
            description: counselor.shortdescription,
            type: 'profile',
        },
    };
}
```

---

### Phase 8: Migration Cutover

#### Step 8.1: Final Pre-Launch Checklist

- [ ] All pages implemented and tested
- [ ] All tests passing (unit, integration, E2E)
- [ ] Visual regression tests pass
- [ ] Performance targets met
- [ ] SEO metadata complete
- [ ] Accessibility audit passed (WCAG AA)
- [ ] Browser compatibility verified (Chrome, Firefox, Safari, Edge)
- [ ] Mobile responsiveness verified
- [ ] Google Maps integration working
- [ ] All assets loading correctly
- [ ] 404 page implemented
- [ ] Error boundaries implemented

---

#### Step 8.2: Request Human Review of All Local Changes

**Actions**:

1. Review all code changes in Git
2. Verify SOLID principles applied
3. Check test coverage reports
4. Review bundle size analysis
5. Verify no console errors in production build

**Command**:

```bash
git diff main...issue-2 --stat
git diff main...issue-2
npm run build
npm run start
# Manual comprehensive testing
```

---

#### Step 8.3: Create Pull Request

**PR Title**: `feat: Migrate to Next.js 15 with Tailwind CSS (Issue #2)`

**PR Description Template**:

```markdown
## Overview

Migrates CompassLex.com from Angular 20 to Next.js 15 with Tailwind CSS, maintaining exact functionality and appearance.

## Changes

- ✅ Next.js 15 App Router setup
- ✅ Tailwind CSS configuration matching existing design
- ✅ All 9 pages implemented
- ✅ Google Maps integration
- ✅ Data repository layer for JSON files
- ✅ Comprehensive test coverage (unit, integration, E2E)
- ✅ Vercel deployment configuration

## Testing

- [x] Unit tests: 100+ tests passing
- [x] Integration tests: all passing
- [x] E2E tests: all critical flows covered
- [x] Visual regression: no unexpected changes
- [x] Performance: Lighthouse score >90
- [x] Accessibility: WCAG AA compliant

## SOLID Principles Applied

- **SRP**: Each component/service has single responsibility
- **OCP**: Data repository allows future DB migration
- **LSP**: All components follow React.FC interface
- **ISP**: Minimal, focused interfaces
- **DIP**: Components depend on abstractions

## Checklist

- [x] Code follows project standards
- [x] Tests written and passing
- [x] Documentation updated (README.md)
- [x] No TypeScript errors
- [x] No ESLint errors
- [x] Prettier formatting applied
- [x] Deployment tested on Vercel preview

## Screenshots

[Attach comparison screenshots: Angular vs Next.js]

## Deployment Notes

- Environment variable `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY` must be set in Vercel
- Automatic deployment configured on merge to main
```

**Create PR**:

```bash
git push origin issue-2
gh pr create --title "feat: Migrate to Next.js 15 with Tailwind CSS (Issue #2)" --body-file .github/pr-template.md
```

---

#### Step 8.4: After PR Approval, Squash and Merge

**Actions**:

1. Address any PR review comments
2. Ensure all CI checks pass
3. Squash commits into single commit
4. Merge to main
5. Verify Vercel production deployment
6. Monitor for errors in production

**Command**:

```bash
gh pr merge --squash --delete-branch
```

---

## Verification Process (Applied After EACH Implementation Step)

### Verification Commands

```bash
# 1. TypeScript compilation check
tsc --noEmit

# 2. ESLint (with auto-fix)
npx eslint --fix {files}

# 3. Prettier formatting
npx prettier --write {files}

# 4. Unit tests for related files
npx vitest related run {files}
```

### Verification Steps

1. **Identify Modified Files**: After completing an implementation step, list all files created/modified

2. **Run Verification Commands**: Replace `{files}` with space-separated file paths

3. **Handle Failures**:
    - If any command fails, fix the specific error
    - Retry the verification step
    - If failures persist beyond **3 attempts**, STOP and document the issue
    - Request human guidance

4. **Proceed Only on Success**: All verifications must pass before moving to next step

### Example Verification Workflow

```powershell
# Step 1.2 completed - Data Repository Layer
# Files modified: services/data-repository.ts, __tests__/services/data-repository.test.ts

# Verification (npm/npx commands work identically in PowerShell):
tsc --noEmit
npx eslint --fix services/data-repository.ts __tests__/services/data-repository.test.ts
npx prettier --write services/data-repository.ts __tests__/services/data-repository.test.ts
npx vitest related run services/data-repository.ts

# All pass ✓ → Proceed to Step 1.3
# Any fail ✗ → Fix and retry (max 3 attempts)
```

---

## Testing Strategy

### Test-Driven Development (TDD) Approach

**Red-Green-Refactor Cycle**:

1. **RED**: Write failing test first
    - Define expected behavior
    - Test fails because implementation doesn't exist

2. **GREEN**: Write minimum code to pass test
    - Focus on making test pass, not perfect code
    - Verify test passes

3. **REFACTOR**: Improve code while keeping tests green
    - Extract functions, improve naming
    - Apply SOLID principles
    - Ensure tests still pass

### Unit Testing (Vitest + React Testing Library)

**Coverage**:

- Components: Test rendering, props, user interactions
- Services: Test all methods, error handling
- Utilities: Test pure functions, edge cases

**Test Files**: Colocated in `__tests__/` directory

**Example**:

```typescript
// __tests__/components/counselor-card.test.tsx
import { describe, it, expect } from 'vitest'
import { render, screen } from '@testing-library/react'
import CounselorCard from '@/components/counselor-card'

describe('CounselorCard', () => {
  const mockCounselor = {
    firstname: 'John',
    lastname: 'Doe',
    shortdescription: 'Test description',
    titles: ['M.A.'],
    // ... other required fields
  }

  it('should render counselor name', () => {
    render(<CounselorCard counselor={mockCounselor} />)
    expect(screen.getByText('John Doe')).toBeInTheDocument()
  })

  it('should display short description', () => {
    render(<CounselorCard counselor={mockCounselor} />)
    expect(screen.getByText('Test description')).toBeInTheDocument()
  })
})
```

### Integration Testing

**Scope**: Test multiple components working together

**Example**:

- Navigation + Page routing
- Form submission + Server action
- Data loading + Component rendering

### E2E Testing (Playwright)

**Critical User Flows**:

1. Browse counselor list → View counselor detail
2. View newsletter list → Download PDF
3. Mobile navigation menu
4. Navigate between all pages

**Test Files**: `e2e/` directory

### Manual Testing Scenarios

**After implementation complete**:

1. Visual comparison: Angular app vs Next.js app (side-by-side)
2. Cross-browser testing: Chrome, Firefox, Safari, Edge
3. Mobile responsive testing: iPhone, iPad, Android
4. Accessibility testing: Screen reader, keyboard navigation
5. Performance testing: Lighthouse audits

### Test Data Requirements

**Setup**:

- Use real `counselor.json` and `newsletter.json` for integration tests
- Mock data for unit tests
- Playwright uses localhost with real data

### Test Coverage Goals

- **Components**: >80% coverage
- **Services**: >90% coverage
- **Pages**: >70% coverage
- **Overall**: >75% coverage

**Command**:

```bash
npx vitest run --coverage
```

### Regression Tests

**Ensure existing functionality not broken**:

- All counselor data displays correctly
- All newsletter data displays correctly
- Navigation works across all pages
- Google Maps displays correctly

---

## Considerations

### Security Implications

1. **Environment Variables**: Ensure Google Maps API key not exposed in client bundle
    - Use `NEXT_PUBLIC_` prefix only for client-side variables
    - Server-side secrets in `.env.local` (git-ignored)

2. **Form Validation**: Server-side validation using Zod
    - Never trust client-side validation alone
    - Sanitize HTML inputs to prevent XSS

3. **Content Security Policy**: Configure CSP headers in Next.js config

4. **HTTPS**: Vercel provides automatic HTTPS

### Performance Impacts

**Improvements**:

- Static generation eliminates JSON HTTP requests
- Server Components reduce client JavaScript
- Automatic code splitting by route
- Image optimization with Next.js `<Image>`

**Monitoring**:

- Vercel Analytics for real user monitoring
- Lighthouse CI in GitHub Actions
- Core Web Vitals tracking

### Database Migration Preparation

**Current**: JSON files in `public/data/`

**Future**: Abstract data access through repository interfaces

**Migration Path**:

1. Replace `CounselorRepository` implementation with database queries
2. No component changes needed (depends on interface)
3. Add database connection in `lib/db.ts`

**Repository Pattern Benefits**:

- Components never directly access files or database
- Can swap implementations without touching UI code
- Testable with mock repositories

### Backward Compatibility

**N/A**: Complete platform migration, not incremental change

**Considerations**:

- Old Angular URLs should still work (same route structure)
- Bookmark URLs preserved
- External links to counselor pages remain valid

### Documentation Updates

**Files to Update**:

1. **README.md**:
    - Update tech stack section
    - Replace Angular commands with Next.js commands
    - Update deployment instructions
    - Add Vercel deployment notes

2. **CLAUDE.md**:
    - Replace entire file with Next.js architecture
    - Document new data repository pattern
    - Update command reference
    - Add Tailwind configuration notes

3. **CONTRIBUTING.md** (if exists):
    - Update development workflow
    - Update testing instructions

4. **package.json**:
    - Update scripts section
    - Update project description

**Example README.md Update**:

````markdown
# CompassLex.com

This project is built with [Next.js 15](https://nextjs.org) and [Tailwind CSS](https://tailwindcss.com).

## Getting Started

1. Install dependencies:
    ```bash
    npm install
    ```
````

2. Set up environment variables:

    ```bash
    cp .env.example .env.local
    # Add your Google Maps API key to .env.local
    ```

3. Run the development server:

    ```bash
    npm run dev
    ```

4. Open [http://localhost:3000](http://localhost:3000)

## Tech Stack

- **Framework**: Next.js 15 (App Router)
- **Styling**: Tailwind CSS
- **Language**: TypeScript
- **Testing**: Vitest, React Testing Library, Playwright
- **Deployment**: Vercel

## Project Structure

- `app/` - Next.js app router pages and layouts
- `components/` - Reusable React components
- `services/` - Data access layer (repository pattern)
- `types/` - TypeScript type definitions
- `public/` - Static assets and data files
- `__tests__/` - Unit and integration tests
- `e2e/` - Playwright end-to-end tests

## Available Commands

- `npm run dev` - Start development server
- `npm run build` - Build for production
- `npm run start` - Start production server
- `npm run lint` - Run ESLint
- `npm run test` - Run Vitest tests
- `npm run test:coverage` - Run tests with coverage
- `npm run e2e` - Run Playwright E2E tests

## Deployment

The application is deployed on Vercel with automatic deployments on push to main branch.

### Environment Variables

Required environment variables in Vercel:

- `NEXT_PUBLIC_GOOGLE_MAPS_API_KEY` - Google Maps API key

```

---

## Risk Assessment and Mitigation

### High-Risk Areas

1. **Visual Parity**: Ensuring pixel-perfect match
   - **Mitigation**: Visual regression testing, manual side-by-side comparison

2. **Data Integrity**: Ensuring all counselor/newsletter data displays correctly
   - **Mitigation**: Data validation tests, manual verification of all 11 counselors

3. **SEO Impact**: Potential ranking drops during migration
   - **Mitigation**: Proper meta tags, structured data, 301 redirects if needed

4. **Google Maps**: Integration complexity
   - **Mitigation**: Test early in process, use proven React wrapper

### Medium-Risk Areas

1. **Contact Form**: Email delivery setup
   - **Mitigation**: Test with real email service, add error logging

2. **Mobile Responsiveness**: Ensuring all devices work correctly
   - **Mitigation**: Test on real devices, use browser dev tools

3. **Performance**: Potential slowdowns
   - **Mitigation**: Lighthouse monitoring, bundle analysis

### Low-Risk Areas

1. **Newsletter PDFs**: Static file serving
   - **Mitigation**: Simple copy to `public/` directory

2. **Routing**: Next.js App Router well-established
   - **Mitigation**: Follow Next.js best practices

---

## Timeline and Phases

### Week 1: Foundation
- Steps 0.1 - 1.3: Setup, TypeScript, Data Layer
- Deliverable: Data repository with tests passing

### Week 2: UI Framework
- Steps 2.1 - 2.2: Tailwind config, reusable components
- Deliverable: Design system components with Storybook (optional)

### Week 3: Page Implementation (Part 1)
- Steps 3.1 - 4.3: Layout, navigation, home, meet-us, counselor detail
- Deliverable: Core pages implemented and tested

### Week 4: Page Implementation (Part 2)
- Steps 4.4 - 4.9: Newsletters, contact, remaining pages
- Deliverable: All pages implemented

### Week 5: Integrations and Testing
- Step 5.1: Google Maps
- Steps 6.1 - 6.4: Comprehensive testing
- Deliverable: Full test suite passing

### Week 6: Deployment and Launch
- Steps 7.1 - 7.4: Vercel config, optimization, SEO
- Steps 8.1 - 8.4: Final review, PR, merge, deploy
- Deliverable: Live on Vercel

---

## Success Metrics

### Code Quality Metrics
- ✅ 0 TypeScript errors
- ✅ 0 ESLint errors
- ✅ 100% Prettier formatting compliance
- ✅ >75% test coverage overall
- ✅ >90% service layer test coverage

### Performance Metrics
- ✅ Lighthouse Performance Score: >90
- ✅ First Contentful Paint: <1.5s
- ✅ Time to Interactive: <3s
- ✅ Cumulative Layout Shift: <0.1
- ✅ Total Bundle Size: <300KB (gzipped)

### Functional Metrics
- ✅ All 11 counselor profiles display correctly
- ✅ All 24 newsletters accessible
- ✅ All 9 pages functional
- ✅ Google Maps displays with marker
- ✅ Mobile menu works on small screens
- ✅ All PDFs downloadable

### User Experience Metrics
- ✅ Pixel-perfect visual match to Angular app
- ✅ No console errors in production
- ✅ Passes WCAG AA accessibility audit
- ✅ Works in Chrome, Firefox, Safari, Edge
- ✅ Responsive on mobile, tablet, desktop

---

## Approval Required

This plan represents a comprehensive migration strategy from Angular to Next.js. Before proceeding with implementation, please review and approve:

1. **Development Environment**: Windows 11 with PowerShell (all shell commands use PowerShell syntax)
2. **Repository Approach**: Separate `compasslex-nextjs` repository with Angular repo as read-only reference
3. **Technical Approach**: Repository pattern, Server Components, Tailwind CSS
4. **Testing Strategy**: TDD approach with unit, integration, and E2E tests
5. **Timeline**: 6-week estimated timeline
6. **SOLID Principles**: Application throughout architecture

**Next Steps After Approval**:
1. Begin with Phase 0, Step 0.3: Set Up Development Environment (Steps 0.1-0.2 already completed)
2. Follow TDD discipline: Red-Green-Refactor for each step
3. Run verification commands after each step
4. Request human review before creating PR

---

## Implementation Decisions

1. **Development Environment**: ✅ RESOLVED - Windows 11 workstation using PowerShell. All shell commands in this specification use PowerShell syntax (e.g., `Copy-Item -Recurse` instead of `cp -r`). npm/npx/git commands work identically in PowerShell.

2. **Repository Structure**: ✅ RESOLVED - Separate `compasslex-nextjs` repository created using Vercel's Next.js Boilerplate. Angular repo (`compasslex.com`) serves as read-only reference located adjacent to Next.js repo. Claude Code will work from Next.js repo and reference Angular repo via relative paths (`../compasslex.com/`).

3. **Contact Form**: ✅ RESOLVED - No contact form currently exists in the Angular app. The Next.js migration will not add one at this time. This may be added as a future enhancement.

4. **Analytics**: ✅ RESOLVED - Will not add analytics at this point, though this might be added in a future enhancement.

5. **CI/CD**: ✅ RESOLVED - Will use standard Vercel deployment from GitHub. Manual setup by project owner (no GitHub Actions needed at this time).

6. **Error Tracking**: ✅ RESOLVED - Will not add error tracking at this point, though this might be added in a future enhancement.

7. **CMS Integration**: 🔄 FUTURE CONSIDERATION - Any plans for future CMS integration for counselor/newsletter management? (Can be addressed later)

---

**Plan Created**: 2026-01-21T10:54:35
**Last Updated**: 2026-01-21T11:10:00
**Status**: ✅ Ready for Approval (Windows/PowerShell Environment Confirmed)
**Estimated Duration**: 6 weeks
**Complexity**: HIGH
**Risk Level**: MEDIUM (well-mitigated)
```
